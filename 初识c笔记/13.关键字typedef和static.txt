typedef 顾名思义是类型定义，这里应该理解为类型重命名

typedef unsigned int uint;

typedef struct Node
{
	int data;
	struct Node* next;
}Node;

int main()
{
	unsigned int num = 0;
	uint num1 = 1;
	struct Node n;
	Node n2;

	return 0;
}


一块大内存
分为  栈区、堆区和静态区
栈区存放：局部变量...
堆区存放：动态内存管理、malloc/free、calloc、realloc
静态区存放：静态变量、全局变量
放在静态区的数据出作用域不销毁，程序生命周期结束才销毁




在C语言中：
static是用来修饰变量和函数的
1.修饰局部变量-称为静态局部变量
2.修饰全局变量-称为静态全部变量
3.修饰函数-称为静态函数


1.static修饰局部变量的时候，局部变量出了作用域，不销毁的。
本质上，static修饰局部变量的时候，改变了变量的存储位置的

影响了变量的生命周期，生命周期变长，和程序的生命周期一样，不改变作用域。
有static修饰的变量会在静态区分配内存，没有在栈区分配内存


#include <stdio.h>

void text()//void  定义返回值为空，所以函数没有返回值
{
	//修饰局部变量
	static int a = 1;
	a++;
	printf("%d ", a);
}
int main()
{
	int i = 0;
	while (i < 10)
	{
		text();
		i++;
	}

	return 0;
}



2.static 修饰全局变量的时候
这个全局变量的外部链接属性
就变成了内部链接属性
其他源文件(.c)就不能再使用到这个全局变量了

我们在使用的时候就感觉作用域是变小了




全局变量和函数具有外部链接属性

3.static修饰函数
一个函数本来是具有外部链接属性的
但是被static修饰的时候，外部连接属性
就变成了内部链接属性，其他源文件(.c)
就无法使用了




register - 寄存器

电脑上的存储设备有
寄存器（集成到cpu上）
高速缓存（cache）
内存
硬盘


int main()
{
	//寄存器变量
	register int num = 3;//建议：3存放在寄存中

	return 0;
}




.h 头文件（函数的声明、类型的声明、头文件的包含）
.c 源文件（函数实现）


浮点数的四舍五入，不能用肉眼看的数值来计算
因为浮点数在内存中可能不能精确保存



